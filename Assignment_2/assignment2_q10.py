# -*- coding: utf-8 -*-
"""Assignment2_Q10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nAdzOL4QnY4dVvlKBojtD4yWvcTl-o-i
"""

import numpy as np

def compute_jacobian(theta1, theta2, theta3, a1, a2, a3):
    # Transformation matrices from base to joint frames
    T01 = np.array([[np.cos(theta1), -np.sin(theta1), 0, 0],
                    [np.sin(theta1), np.cos(theta1), 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

    T12 = np.array([[np.cos(theta2), -np.sin(theta2), 0, a1],
                    [np.sin(theta2), np.cos(theta2), 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

    T23 = np.array([[np.cos(theta3), -np.sin(theta3), 0, a2],
                    [np.sin(theta3), np.cos(theta3), 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

    # End-effector transformation matrix
    T34 = np.array([[1, 0, 0, a3],
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

    # Calculate the transformation matrix from base to end-effector frame
    T04 = np.dot(np.dot(np.dot(T01, T12), T23), T34)

    # Extract the position components (x, y, z) of the end-effector
    x = T04[0, 3]
    y = T04[1, 3]
    z = T04[2, 3]

    # Compute linear velocity Jacobian matrix (Jv)
    Jv = np.array([[0, -a1 * np.sin(theta1), -a2 * np.sin(theta1 + theta2)],
                   [0, a1 * np.cos(theta1), a2 * np.cos(theta1 + theta2)],
                   [1, 0, 0]])

    # Compute angular velocity Jacobian matrix (Jω)
    Jw = np.array([[0, 0, 0],
                   [0, 0, 0],
                   [1, 1, 1]])  # 3x3 identity matrix, assuming all joints are in the Z-axis rotation

    # Combine Jv and Jω to get the full Jacobian matrix (J)
    J = np.vstack((Jv, Jw))

    return J

# Example: Compute Jacobian for given joint angles and link lengths
theta1 = np.pi/4  # Replace with actual values
theta2 = np.pi/3
theta3 = np.pi/6
a1 = 1.0
a2 = 1.0
a3 = 1.0

Jacobian = compute_jacobian(theta1, theta2, theta3, a1, a2, a3)

# Display the Jacobian matrix
print("Jacobian matrix:")
print(Jacobian)