# -*- coding: utf-8 -*-
"""Assignment2_Q8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L8EpKX1SsNHbU0hY1oovi68bONgkC1XP
"""

import numpy as np

def compute_jacobian(theta1, theta2, d3, a1, a2, a3):
    # Transformation matrices from base to joint frames
    T01 = np.array([[np.cos(theta1), -np.sin(theta1), 0, 0],
                    [np.sin(theta1), np.cos(theta1), 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

    T12 = np.array([[np.cos(theta2), -np.sin(theta2), 0, a1],
                    [np.sin(theta2), np.cos(theta2), 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

    # End-effector transformation matrix (Note: d3 represents the prismatic joint)
    T23 = np.array([[1, 0, 0, 0],
                    [0, 1, 0, 0],
                    [0, 0, 1, d3],
                    [0, 0, 0, 1]])

    T34 = np.array([[1, 0, 0, a3],
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

    # Calculate the transformation matrix from base to end-effector frame
    T04 = np.dot(np.dot(np.dot(T01, T12), T23),T34)

    # Extract the position components (x, y, z) of the end-effector
    x = T04[0, 3]
    y = T04[1, 3]
    z = T04[2, 3]

    # Compute linear velocity Jacobian matrix (Jv) with respect to the joint frames
    Jv = np.array([[-a1 * np.sin(theta1) - a2 * np.sin(theta1 + theta2), -a2 * np.sin(theta1 + theta2), 0, 0],
                   [a1 * np.cos(theta1) + a2 * np.cos(theta1 + theta2), a2 * np.cos(theta1 + theta2), 0, 0],
                   [0,0,-1,0]])

    # Compute angular velocity Jacobian matrix (Jω) with respect to the joint frames
    Jw = np.array([[0, 0, 0, 0],
                   [0, 0, 0, 0],
                   [1, 1, 0 ,-1]])

    # Combine Jv and Jω to get the full Jacobian matrix (J)
    J = np.vstack((Jv, Jw))

    return J

# Example: Compute Jacobian for given joint angles and link lengths
theta1 = np.pi/4  # Replace with actual values
theta2 = np.pi/3
d3 = 0.5  # Prismatic joint displacement
a1 = 1.0
a2 = 1.0
a3 = 0.5

Jacobian = compute_jacobian(theta1, theta2, d3, a1, a2, a3)

# Display the Jacobian matrix
print("Jacobian matrix:")
print(Jacobian)