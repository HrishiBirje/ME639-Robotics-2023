# -*- coding: utf-8 -*-
"""Miniproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11UxLU1mCfaV8v0mOf06AUPb7AQj-38XV
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Defining constants for the 2R manipulator
l1 = 1.0  # length of the first link (m)
l2 = 1.0  # length of the second link (m)

# Trajectory function for x and y coordinates
def trajectory(t):
    radius = 1.6
    angular_velocity = 00.35
    x = radius * np.cos(angular_velocity * t)
    y = radius * np.sin(angular_velocity * t)
    return x, y

# Inverse kinematics function to calculate joint angles from x and y
def inverse_kinematics(x, y):
    r = np.sqrt(x**2 + y**2)
    phi = np.arccos((x**2 + y**2 - l1**2 - l2**2) / (2 * l1 * l2))
    alpha = np.arctan2(y, x)
    beta = np.arctan2(l2 * np.sin(phi), l1 + l2 * np.cos(phi))
    theta1 = alpha - beta
    theta2 = theta1 + phi
    return theta1, theta2

# Time array
t_max = 10.0
num_steps = 1000
time = np.linspace(0, t_max, num_steps)

# Create animation
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
link1, = ax.plot([], [], 'b-', lw=4)
link2, = ax.plot([], [], 'r-', lw=4)

def init():
    link1.set_data([], [])
    link2.set_data([], [])
    return link1, link2

def animate(i):
    t = time[i]
    desired_x, desired_y = trajectory(t)
    desired_theta1, desired_theta2 = inverse_kinematics(desired_x, desired_y)

    x1 = l1 * np.cos(desired_theta1)
    y1 = l1 * np.sin(desired_theta1)
    x2 = x1 + l2 * np.cos(desired_theta2)
    y2 = y1 + l2 * np.sin(desired_theta2)

    link1.set_data([0, x1], [0, y1])
    link2.set_data([x1, x2], [y1, y2])

    return link1, link2

ani = FuncAnimation(fig, animate, frames=num_steps, init_func=init, blit=True, interval=(t_max / num_steps) * 1000)

plt.xlabel('X')
plt.ylabel('Y')
plt.title('2R Manipulator Animation')
plt.grid()

from IPython.display import HTML
HTML(ani.to_jshtml())

"""Task 1 (without dynamics)"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Defining constants for the 2R manipulator
l1 = 1.0  # length of the first link (m)
l2 = 1.0  # length of the second link (m)
N = 10.0 # normal force to be applied

#wall
x_a = 2
y_a = 1.41
x_b = 0
y_b = 1.41
m = np.arctan((y_a - y_b)/(x_a - x_b)) #slope
i = [x_a, x_b]
j = [y_a, y_b]

# Inverse kinematics function to calculate joint angles from x and y
def inverse_kinematics(x, y):
    r = np.sqrt(x**2 + y**2)
    phi = np.arccos((x**2 + y**2 - l1**2 - l2**2) / (2 * l1 * l2))
    alpha = np.arctan2(y, x)
    beta = np.arctan2(l2 * np.sin(phi), l1 + l2 * np.cos(phi))
    theta1 = alpha - beta
    theta2 = theta1 + phi
    return theta1, theta2

# Specify the starting and target locations
x0, y0 = 0.0, 0.0  # Starting location
x1, y1 = 1.41, 1.41   # Target location

theta1_desired, theta2_desired = inverse_kinematics(x1, y1)

# Theta array
num_steps = 10
theta1r = np.linspace(0, theta1_desired , num_steps)
theta2r = np.linspace(0, theta2_desired , num_steps)

# Create animation
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
ax.plot(i, j, label='wall')  # Plot the wall line

link1, = ax.plot([], [], 'b-', lw=4)
link2, = ax.plot([], [], 'r-', lw=4)

def init():
    link1.set_data([], [])
    link2.set_data([], [])
    return link1, link2

def animate(i, ax):

    x1 = l1 * np.cos(theta1r[i])
    y1 = l1 * np.sin(theta1r[i])
    x2 = x1 + l2 * np.cos(theta2r[i])
    y2 = y1 + l2 * np.sin(theta2r[i])

    link1.set_data([0, x1], [0, y1])
    link2.set_data([x1, x2], [y1, y2])

    return link1, link2

ani = FuncAnimation(fig, animate, fargs=(ax,), frames=num_steps, init_func=init, blit=True, interval=(t_max / num_steps) * 1000)

plt.xlabel('X')
plt.ylabel('Y')
plt.title('2R Manipulator Animation')
plt.grid()

# Calculating normals along axis
Nx = N * np.sin(m)
Ny = N * np.cos(m)
Norm = np.array([[Nx],[Ny]])

# Jacobian
Jt = np.array([[(-l1 * np.sin(theta1_desired)), (l1 * np.cos(theta1_desired))],
              [(-l2 * np.sin(theta2_desired)), (l2 * np.cos(theta2_desired))]])

# Calculating torques
T = np.dot(Jt, Norm)

print('Normal Force = ', N)
print('Torque 1 = ', T[0,0])
print('Torque 2 = ', T[1,0])


from IPython.display import HTML
HTML(ani.to_jshtml())

"""Task 2"""

import numpy as np
import matplotlib.pyplot as plt

# Defining constants for the 2R manipulator
l1 = 1.0  # length of the first link (m)
l2 = 1.0  # length of the second link (m)

# Range of joint angles (in radians)
theta_range = np.deg2rad(np.linspace(35, 145, 100))
workspace_points = []

# Calculate end-effector positions for each combination of joint angles
for theta1 in theta_range:
    for theta2 in theta_range:
        x2 = l1 * np.cos(theta1) + l2 * np.cos(theta2)
        y2 = l1 * np.sin(theta1) + l2 * np.sin(theta2)
        workspace_points.append((x2, y2))

# Extract x and y coordinates for plotting
workspace_x = [point[0] for point in workspace_points]
workspace_y = [point[1] for point in workspace_points]

# Plot the workspace
plt.figure(figsize=(8, 8))
plt.scatter(workspace_x, workspace_y, s=1)
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Workspace of 2R Manipulator')
plt.xlim(-2, 2)
plt.ylim(-2, 2)
plt.grid()
plt.show()

"""Task 4"""

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Define system parameters
m1 = 1.0    # mass of the first link (kg)
m2 = 1.0    # mass of the second link (kg)
l1 = 1.0    # length of the first link (m)
l2 = 1.0    # length of the second link (m)

# Inverse kinematics function to calculate joint angles from x and y
def inverse_kinematics(x, y):
    r = np.sqrt(x**2 + y**2)
    phi = np.arccos((x**2 + y**2 - l1**2 - l2**2) / (2 * l1 * l2))
    alpha = np.arctan2(y, x)
    beta = np.arctan2(l2 * np.sin(phi), l1 + l2 * np.cos(phi))
    theta1 = alpha - beta
    theta2 = phi
    return theta1, theta2

# Specify the starting and target locations
x0, y0 = 2.0, 0.0  # Starting location
x1, y1 = 1.41, 1.41   # Target location

desired_theta1, desired_theta2 = inverse_kinematics(x1, y1)


# Define the Lagrange's equations of motion
def lagrange_equations(state, t, torque1, torque2):
    theta1, theta2, theta1_dot, theta2_dot = state

    # Inertia tensors
    I1 = (1/3) * m1 * l1**2
    I2 = (1/3) * m2 * l2**2

    # Mass matrix
    M11 = (m1 + m2) * l1**2 + m2 * l2**2 + 2 * m2 * l1 * l2 * np.cos(theta2)
    M12 = m2 * l2**2 + m2 * l1 * l2 * np.cos(theta2)
    M21 = M12
    M22 = m2 * l2**2

    # Coriolis and centrifugal terms
    c1 = -m2 * l1 * l2 * theta2_dot * (2 * theta1_dot + theta2_dot) * np.sin(theta2)
    c2 = m2 * l1 * l2 * theta1_dot**2 * np.sin(theta2)

    # Equations of motion
    theta1_ddot = (M22 * (torque1 - c1 - c2) - M12 * (torque2 + c1)) / (M11 * M22 - M12 * M21)
    theta2_ddot = (M11 * (torque2 + c1) - M21 * (torque1 - c1 - c2)) / (M11 * M22 - M12 * M21)

    return [theta1_dot, theta2_dot, theta1_ddot, theta2_ddot]

# PD control gains
kp = 1.0  # Proportional gain
kd = 1.0   # Derivative gain

# PD control function to calculate torques
def pd_control(current_theta1, current_theta2, current_theta1_dot, current_theta2_dot, desired_theta1, desired_theta2):
    error_theta1 = desired_theta1 - current_theta1
    error_theta2 = desired_theta2 - current_theta2
    torque1 = kp * error_theta1 - kd * current_theta1_dot
    torque2 = kp * error_theta2 - kd * current_theta2_dot
    return torque1, torque2

# Initial conditions
initial_state = [0.0, 0.0, 0.0, 0.0]  # theta1, theta2, theta1_dot, theta2_dot

# Time array
t_max = 40.0
num_steps = 400
time = np.linspace(0, t_max, num_steps)

# Animation function
def animate(i):
    global solutions

    current_theta1 = theta1_solutions[i]
    current_theta2 = theta2_solutions[i]

    torque1, torque2 = pd_control(current_theta1, current_theta2, theta1_dot_solutions[i], theta2_dot_solutions[i], desired_theta1, desired_theta2)

    solutions = odeint(lagrange_equations, solutions[-1], [time[i], time[i + 1]], args=(torque1, torque2))

    theta1_solutions[i + 1] = solutions[-1, 0]
    theta2_solutions[i + 1] = solutions[-1, 1]
    theta1_dot_solutions[i + 1] = solutions[-1, 2]
    theta2_dot_solutions[i + 1] = solutions[-1, 3]

    theta1 = theta1_solutions[i + 1]
    theta2 = theta2_solutions[i + 1]

    x1 = l1 * np.cos(theta1)
    y1 = l1 * np.sin(theta1)
    x2 = x1 + l2 * np.cos(theta1 + theta2)
    y2 = y1 + l2 * np.sin(theta1 + theta2)

    link1.set_data([0, x1], [0, y1])
    link2.set_data([x1, x2], [y1, y2])

    return link1, link2

# Solve the equations of motion using odeint with PD control
solutions = odeint(lagrange_equations, initial_state, time, args=(0.0, 0.0))

# Extract solutions for theta1, theta2, theta1_dot, theta2_dot
theta1_solutions = solutions[:, 0]
theta2_solutions = solutions[:, 1]
theta1_dot_solutions = solutions[:, 2]
theta2_dot_solutions = solutions[:, 3]

# Create animation
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
link1, = ax.plot([], [], 'b-', lw=4)
link2, = ax.plot([], [], 'r-', lw=4)

ani = FuncAnimation(fig, animate, frames=num_steps - 1, blit=True, interval=(t_max / num_steps) * 1000)

plt.xlabel('X')
plt.ylabel('Y')
plt.title('2R Manipulator Animation')
plt.grid()

from IPython.display import HTML
HTML(ani.to_jshtml())

"""Task 1 (with dynamics)"""

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Define system parameters
m1 = 1.0    # mass of the first link (kg)
m2 = 1.0    # mass of the second link (kg)
l1 = 1.0    # length of the first link (m)
l2 = 1.0    # length of the second link (m)
k = 0.2    # spring constant

# Define the Lagrange's equations of motion with spring force
def lagrange_equations(state, t):
    theta1, theta2, theta1_dot, theta2_dot = state

    # Inertia tensors
    I1 = (1/3) * m1 * l1**2
    I2 = (1/3) * m2 * l2**2

    # Mass matrix
    M11 = (m1 + m2) * l1**2 + m2 * l2**2 + 2 * m2 * l1 * l2 * np.cos(theta2)
    M12 = m2 * l2**2 + m2 * l1 * l2 * np.cos(theta2)
    M21 = M12
    M22 = m2 * l2**2

    # Coriolis and centrifugal terms
    c1 = -m2 * l1 * l2 * theta2_dot * (2 * theta1_dot + theta2_dot) * np.sin(theta2)
    c2 = m2 * l1 * l2 * theta1_dot**2 * np.sin(theta2)

    # Spring force components
    spring_force_x = -k * (x2 - x_s)
    spring_force_y = -k * (y2 - y_s)

    # Calculate torques as a result of spring force
    torque1 = - spring_force_x * l1 * np.sin(theta1) + spring_force_y * l1 * np.cos(theta1)
    torque2 = - spring_force_x * l2 * np.sin(theta1 + theta2) + spring_force_y * l2 * np.cos(theta1 + theta2)

    # Equations of motion
    theta1_ddot = (M22 * torque1 - M12 * torque2 - c1 - c2) / (M11 * M22 - M12 * M21)
    theta2_ddot = (M11 * torque2 - M21 * torque1 + c1) / (M11 * M22 - M12 * M21)

    return [theta1_dot, theta2_dot, theta1_ddot, theta2_ddot]

# Initial conditions
initial_state = [0.0, 0.0, 0.0, 0.0]  # theta1, theta2, theta1_dot, theta2_dot

# Time array
t_max = 10.0
num_steps = 250
time = np.linspace(0, t_max, num_steps)

# Arbitrary points for spring attachment and initial end effector position
x_s, y_s = 1, 1
x2, y2 = 2, 0  # Initial position of the end effector

# Solve the equations of motion using odeint
solutions = odeint(lagrange_equations, initial_state, time)

# Extract solutions for theta1, theta2, theta1_dot, theta2_dot
theta1_solutions = solutions[:, 0]
theta2_solutions = solutions[:, 1]
theta1_dot_solutions = solutions[:, 2]
theta2_dot_solutions = solutions[:, 3]

# Animation function
def animate(i):
    theta1 = theta1_solutions[i]
    theta2 = theta2_solutions[i]

    x1 = l1 * np.cos(theta1)
    y1 = l1 * np.sin(theta1)
    x2 = x1 + l2 * np.cos(theta1 + theta2)
    y2 = y1 + l2 * np.sin(theta1 + theta2)

    spring_x = [x2, x_s]
    spring_y = [y2, y_s]

    link1.set_data([0, x1], [0, y1])
    link2.set_data([x1, x2], [y1, y2])
    spring_line.set_data(spring_x, spring_y)

    return link1, link2, spring_line

# Create animation
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)
link1, = ax.plot([], [], 'b-', lw=4)
link2, = ax.plot([], [], 'r-', lw=4)
spring_line, = ax.plot([], [], 'g-', lw=2)

ani = FuncAnimation(fig, animate, frames=num_steps, blit=True, interval=(t_max / num_steps) * 1000)

plt.xlabel('X')
plt.ylabel('Y')
plt.title('2R Manipulator Animation with Attached Spring Torques')
plt.grid()

from IPython.display import HTML
HTML(ani.to_jshtml())

"""Task 3"""