import numpy as np

def calculate_robot_jacobian(theta_a, theta_b, d_c, a_1, a_2, a_3):
    # Transformation matrices from the base to joint frames
    T_AB =  np.array([[np.cos(theta1), 0, -np.sin(theta1), 0],
                    [np.sin(theta1), 0, np.cos(theta1), 0],
                    [0, -1, 0, d1],
                    [0, 0, 0, 1]])


    T_BC = np.array([[np.cos(theta2), 0, np.sin(theta2), 0],
                    [np.sin(theta2), 0, np.cos(theta2), 0],
                    [0, 1, -1, d2],
                    [0, 0, 0, 1]])


    # End-effector transformation matrix (Note: d_c represents the prismatic joint)
    T_CD = np.array([[1, 0, 0, 0],
                    [0, 1, 0, 0],
                    [0, 0, 1, d3],
                    [0, 0, 0, 1]])

    T_DE = np.array([[1, 0, 0, a_3],
                    [0, 1, 0, 0],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]])

  
    T_AE = np.dot(np.dot(np.dot(T_AB, T_BC), T_CD), T_DE)

    # Extract the position components (x, y, z) of the end-effector
    x_pos = T_AE[0, 3]
    y_pos = T_AE[1, 3]
    z_pos = T_AE[2, 3]

    # Compute the linear velocity Jacobian matrix (J_linear) with respect to the joint frames
    J_linear = np.array([[-a_1 * np.sin(theta_a) - a_2 * np.sin(theta_a + theta_b), -a_2 * np.sin(theta_a + theta_b), 0, 0],
                   [a_1 * np.cos(theta_a) + a_2 * np.cos(theta_a + theta_b), a_2 * np.cos(theta_a + theta_b), 0, 0],
                   [0, 0, -1, 0]])

    # Compute the angular velocity Jacobian matrix (J_angular) with respect to the joint frames
    J_angular = np.array([[0, 0, 0, 0],
                   [0, 0, 0, 0],
                   [1, 1, 0 ,-1]])

    # Combine J_linear and J_angular to obtain the full Jacobian matrix (Jacobian)
    Jacobian_matrix = np.vstack((J_linear, J_angular))

    return Jacobian_matrix
